var startDate = '2016-06-10T16:30:00';
var endDate = '2016-09-30T16:30:00';

var centerPoint = ee.Geometry.Point(-121.77653287661818, 36.839911160080)
var boundingBox = centerPoint.buffer(125);

function applyScaleFactors(image) {
  var opticalBands = image.select('SR_B.').multiply(0.0000275).add(-0.2);
  return image.addBands(opticalBands, null, true)
}

function maskClouds(image) {
  var QA60 = image.select(['QA_PIXEL']);
  
  var dilatedCloudBit = 1 << 1;
  var cirrusBit = 1 << 2;
  var cloudBit = 1 << 3;
  var cloudShadowBit = 1 << 4;

  var mask = QA60.bitwiseAnd(cloudBit).eq(0)
  .and(QA60.bitwiseAnd(dilatedCloudBit).eq(0))
  .and(QA60.bitwiseAnd(cirrusBit).eq(0))
  .and(QA60.bitwiseAnd(cloudShadowBit).eq(0));
  return image.updateMask(mask).copyProperties(image).set('system:time_start', image.get('system:time_start'));
}


var originalCollection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
  .filterDate(startDate, endDate)
  .filterBounds(boundingBox)
  .map(maskClouds)
  .map(applyScaleFactors)

print(originalCollection)

var chart = ui.Chart.image.series({
    imageCollection: originalCollection.select('SR_B5'),
    region: boundingBox
    }).setOptions({
      interpolateNulls: true,
      lineWidth: 1,
      pointSize: 3,
      title: 'NIR over Time at Clicked Point',
      vAxis: {title: 'NIR'},
      hAxis: {title: 'Date', format: 'YYYY-MMM', gridlines: {count: 12}}
    });
  print(chart)
  

  
var bandNames = ee.Image(originalCollection.first()).bandNames();
var numBands = bandNames.size();
var initBands = ee.List.repeat(ee.Image(), numBands);
var initImage = ee.ImageCollection(initBands).toBands().rename(bandNames)

var n = 5;
var firstImage = ee.Image(originalCollection.sort('system:time_start').first())
var lastImage = ee.Image(originalCollection.sort('system:time_start', false).first())
var timeStart = ee.Date(firstImage.get('system:time_start'))
var timeEnd = ee.Date(lastImage.get('system:time_start'))

var totalDays = timeEnd.difference(timeStart, 'day');
var daysToInterpolate = ee.List.sequence(0, totalDays, n)

var initImages = daysToInterpolate.map(function(day) {
  var image = initImage.set({
    'system:index': ee.Number(day).format('%d'),
    'system:time_start': timeStart.advance(day, 'day').millis(),
    // Set a property so we can identify interpolated images
    'type': 'interpolated'
  })
  return image
})

var initCol = ee.ImageCollection.fromImages(initImages)

// Merge original and empty collections
var originalCollection = originalCollection.merge(initCol)

// Interpolation

// Add a band containing timestamp to each image
// This will be used to do pixel-wise interpolation later
var originalCollection = originalCollection.map(function(image) {
  var timeImage = image.metadata('system:time_start').rename('timestamp')
  // The time image doesn't have a mask. 
  // We set the mask of the time band to be the same as the first band of the image
  var timeImageMasked = timeImage.updateMask(image.mask().select(0))
  return image.addBands(timeImageMasked).toFloat();
})

// For each image in the collection, we need to find all images
// before and after the specified time-window

// This is accomplished using Joins
// We need to do 2 joins
// Join 1: Join the collection with itself to find all images before each image
// Join 2: Join the collection with itself to find all images after each image

// We first define the filters needed for the join

// Define a maxDifference filter to find all images within the specified days
// The filter needs the time difference in milliseconds
// Convert days to milliseconds

// Specify the time-window to look for unmasked pixel
var days = 45;
var millis = ee.Number(days).multiply(1000*60*60*24)

var maxDiffFilter = ee.Filter.maxDifference({
  difference: millis,
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a lessThanOrEquals filter to find all images after a given image
// This will compare the given image's timestamp against other images' timestamps
var lessEqFilter = ee.Filter.lessThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a greaterThanOrEquals filter to find all images before a given image
// This will compare the given image's timestamp against other images' timestamps
var greaterEqFilter = ee.Filter.greaterThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})


// Apply the joins

// For the first join, we need to match all images that are after the given image.
// To do this we need to match 2 conditions
// 1. The resulting images must be within the specified time-window of target image
// 2. The target image's timestamp must be lesser than the timestamp of resulting images
// Combine two filters to match both these conditions
var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)
// This join will find all images after, sorted in descending order
// This will gives us images so that closest is last
var join1 = ee.Join.saveAll({
  matchesKey: 'after',
  ordering: 'system:time_start',
  ascending: false})
  
var join1Result = join1.apply({
  primary: originalCollection,
  secondary: originalCollection,
  condition: filter1
})
// Each image now as a property called 'after' containing
// all images that come after it within the time-window

// Do the second join now to match all images within the time-window
// that come before each image
var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)
// This join will find all images before, sorted in ascending order
// This will gives us images so that closest is last
var join2 = ee.Join.saveAll({
  matchesKey: 'before',
  ordering: 'system:time_start',
  ascending: true})
  
var join2Result = join2.apply({
  primary: join1Result,
  secondary: join1Result,
  condition: filter2
})

// Each image now as a property called 'before' containing
// all images that come after it within the time-window
var joinedCol = join2Result;

// Do the interpolation

// We now write a function that will be used to interpolate all images
// This function takes an image and replaces the masked pixels
// with the interpolated value from before and after images.

var interpolateImages = function(image) {
  var image = ee.Image(image);
  // We get the list of before and after images from the image property
  // Mosaic the images so we a before and after image with the closest unmasked pixel
  var beforeImages = ee.List(image.get('before'))
  var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()
  var afterImages = ee.List(image.get('after'))
  var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()

  // Interpolation formula
  // y = y1 + (y2-y1)*((t – t1) / (t2 – t1))
  // y = interpolated image
  // y1 = before image
  // y2 = after image
  // t = interpolation timestamp
  // t1 = before image timestamp
  // t2 = after image timestamp
  
  // We first compute the ratio (t – t1) / (t2 – t1)

  // Get image with before and after times
  var t1 = beforeMosaic.select('timestamp').rename('t1')
  var t2 = afterMosaic.select('timestamp').rename('t2')

  var t = image.metadata('system:time_start').rename('t')

  var timeImage = ee.Image.cat([t1, t2, t])

  var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {
    't': timeImage.select('t'),
    't1': timeImage.select('t1'),
    't2': timeImage.select('t2'),
  })
  // You can replace timeRatio with a constant value 0.5
  // if you wanted a simple average
  
  // Compute an image with the interpolated image y
  var interpolated = beforeMosaic
    .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))
  // Replace the masked pixels in the current image with the average value
  var result = image.unmask(interpolated)
  return result.copyProperties(image, ['system:time_start'])
}

var interpolatedCol = ee.ImageCollection(joinedCol.map(interpolateImages))

var regularCol = interpolatedCol.filter(ee.Filter.eq('type', 'interpolated'))


var chart = ui.Chart.image.series({
  imageCollection: regularCol.select('SR_B5'),
  region: boundingBox,
  reducer: ee.Reducer.median(),
  scale: 20
}).setOptions({
      title: 'Regular NIR Time Series',
      interpolateNulls: false,
      vAxis: {title: 'NIR', viewWindow: {min: 0.2, max: 0.6}},
      hAxis: {title: '', format: 'YYYY-MM'},
      lineWidth: 1,
      pointSize: 4,
      series: {
        0: {color: '#238b45'},
      },
    })
print(chart);

var oeel=require('users/OEEL/lib:loadAll');
var order = 3;
var library_sg = oeel.ImageCollection.SavatskyGolayFilter(
        regularCol,
        ee.Filter.maxDifference(1000*3600*24*16, 'system:time_start', null, 'system:time_start'),
        function(infromedImage,estimationImage){
          return ee.Image.constant(ee.Number(infromedImage.get('system:time_start'))
            .subtract(ee.Number(estimationImage.get('system:time_start'))));},
        3,
        ['SR_B5']);
        
print(ui.Chart.image.series(library_sg.select('SR_B5'), boundingBox, ee.Reducer.median(), 30)
    .setOptions({
      title: 'NIR_SG_timeseries_3rd Order',
      interpolateNulls: true,
      lineWidth: 1,
      pointSize: 3,
}));
