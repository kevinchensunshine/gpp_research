var modis = ee.ImageCollection("MODIS/061/MOD09Q1")

var pt = ee.Geometry.Point([-121.794167, 36.846645])
Map.setCenter(-121.798167, 36.846645, 15)
// real NDVI values 
var NDVI = function(image) {
  return image.expression('float(b("NDVI")/10000)')
};

//Rescale
var rescale = function(image) {
  return image.divide(10000).copyProperties(image, ["system:time_start", "system:time_end"])
}

var updatedFeatures = function(feature) {
  var ndviValue = feature.get('sur_refl_b02');
  return feature.addBands(ndviValue).copyProperties(feature);
};

function dataset_ndvi(image) {
  var ndvi = image.normalizedDifference(['sur_refl_b02', 'sur_refl_b01']).rename('NDVI');
  return image.addBands(ndvi);
}

// get the date and convert to DOY

function returnDate(image) { 
  var date = ee.Date(image.get('google:max_source_file_timestamp')).getRelative('day','year').add(1).toFloat();
  return image.addBands(ee.Image.constant(date).select([0],['DOY']).int16());
}

var bitwiseExtract = function(input, fromBit, toBit) {
  if (toBit === undefined) toBit = fromBit
  var maskSize = ee.Number(1).add(toBit).subtract(fromBit)
  var mask = ee.Number(1).leftShift(maskSize).subtract(1)
  return input.rightShift(fromBit).bitwiseAnd(mask)
}

var mask_clouds = function(image) {
  var qa = image.select('State');
  var cloud = bitwiseExtract(qa, 0, 1)
  var mask = qa.bitwiseAnd(cloud).eq(0)// Clear sky conditions
      return image.updateMask(mask).copyProperties(image).set('system:time_start', image.get('system:time_start'));
};


var start_date = '2016-05-10T16:30:00';
var end_date = '2016-10-31T16:30:00';


var original = modis.filterDate(start_date, end_date).filterBounds(pt).map(mask_clouds).map(dataset_ndvi)

print(Chart.image.series(original.select('sur_refl_b02'), pt, ee.Reducer.mean(), 500)//.select('NDVI')
    //.setSeriesNames(['fitted'])
    .setOptions({
      title: 'NIR_timeseries',
      lineWidth: 1,
      pointSize: 3,
}));

print(Chart.image.series(original.select('NDVI'), pt, ee.Reducer.mean(), 500)//.select('NDVI')
    //.setSeriesNames(['fitted'])
    .setOptions({
      title: 'NDVI_timeseries',
      lineWidth: 1,
      pointSize: 3,
}));

var Mod_col = original

print(Mod_col,'Mod_col')



// Add predictors for SG fitting, using date difference
// We prepare for order 3 fitting, but can be adapted to lower order fitting later on
var modis_res = Mod_col.filterDate(start_date, end_date).filterBounds(pt).map(function(img) {
  var dstamp = ee.Date(img.get('system:time_start'))
  var ddiff = dstamp.difference(ee.Date(start_date), 'hour')
  img = img.select(['NDVI', 'sur_refl_b02']).set('date', dstamp)
  return img.addBands(ee.Image(1).toFloat().rename('constant')).
    addBands(ee.Image(ddiff).toFloat().rename('t')).
    addBands(ee.Image(ddiff).pow(ee.Image(2)).toFloat().rename('t2')).
    addBands(ee.Image(ddiff).pow(ee.Image(3)).toFloat().rename('t3'))
})

print(modis_res, 'modis_res')


// Step 2: Set up Savitzky-Golay smoothing
var window_size = 9
var half_window = (window_size - 1)/2

var imageAxis = 0;
var bandAxis = 1;

var order = 3
var coeffFlattener = [['constant', 'x', 'x2', 'x3']]
var indepSelectors = ['constant', 't', 't2', 't3']

var array = modis_res.toArray();
print(array, 'array')

// Solve 
function getLocalFit(i) {
  // Get a slice corresponding to the window_size of the SG smoother
  var subarray = array.arraySlice(imageAxis, ee.Number(i).int(), ee.Number(i).add(window_size).int())
  var predictors = subarray.arraySlice(bandAxis, 2, 2 + order + 1)
  var response = subarray.arraySlice(bandAxis, 0, 1); // NDVI
  var coeff = predictors.matrixSolve(response)

  coeff = coeff.arrayProject([0]).arrayFlatten(coeffFlattener)
  return coeff  
}


// For the remainder, use modis_res as a list of images
modis_res = modis_res.toList(modis_res.size())
print(modis_res,'modis_res size')


var runLength = ee.List.sequence(0, modis_res.size().subtract(window_size))
print(runLength, 'runLength')

// Run the SG filter over the series, and get the smoothed image 
var sg_series = runLength.map(function(i) {
  var ref = ee.Image(modis_res.get(ee.Number(i).add(half_window)))
  return getLocalFit(i).multiply(ref.select(indepSelectors)).reduce(ee.Reducer.sum()).copyProperties(ref,['date','system:time_start'])
})

print(sg_series, 'sg_series')

print(Chart.image.series(sg_series, pt, ee.Reducer.mean(), 500)//.select('NDVI')
    //.setSeriesNames(['fitted'])
    .setOptions({
      title: 'NDVI_SG_timeseries_3rd Order',
      lineWidth: 1,
      pointSize: 3,
}));

sg_series = ee.ImageCollection(sg_series)

var featureCollection = sg_series.map(function(image) {
    var date = ee.Date(image.get('system:time_start')).format('yyyy-MM-dd HH:mm:ss');
    var medianNDVI = image.reduceRegion({
      reducer: ee.Reducer.median(),
      geometry: pt,
      scale: 30
    }).get('sum');
    return ee.Feature(null, {
      'Date': date,
      'NDVI_Median': medianNDVI
    });
  });
  
// Add predictors for SG fitting, using date difference
// We prepare for order 3 fitting, but can be adapted to lower order fitting later on
var modis_res_nir = Mod_col.filterDate(start_date, end_date).filterBounds(pt).map(function(img) {
  var dstamp = ee.Date(img.get('system:time_start'))
  var ddiff = dstamp.difference(ee.Date(start_date), 'hour')
  img = img.select(['sur_refl_b02', 'NDVI']).set('date', dstamp)
  return img.addBands(ee.Image(1).toFloat().rename('constant')).
    addBands(ee.Image(ddiff).toFloat().rename('t')).
    addBands(ee.Image(ddiff).pow(ee.Image(2)).toFloat().rename('t2')).
    addBands(ee.Image(ddiff).pow(ee.Image(3)).toFloat().rename('t3'))
})

print(modis_res_nir, 'modis_res')


// Step 2: Set up Savitzky-Golay smoothing
var window_size = 9
var half_window = (window_size - 1)/2

var imageAxis = 0;
var bandAxis = 1;

var order = 3
var coeffFlattener = [['constant', 'x', 'x2', 'x3']]
var indepSelectors = ['constant', 't', 't2', 't3']

var array = modis_res_nir.toArray();
print(array, 'array')

// Solve 
function getLocalFit(i) {
  // Get a slice corresponding to the window_size of the SG smoother
  var subarray = array.arraySlice(imageAxis, ee.Number(i).int(), ee.Number(i).add(window_size).int())
  var predictors = subarray.arraySlice(bandAxis, 2, 2 + order + 1)
  var response = subarray.arraySlice(bandAxis, 0, 1); // NDVI
  var coeff = predictors.matrixSolve(response)

  coeff = coeff.arrayProject([0]).arrayFlatten(coeffFlattener)
  return coeff  
}


// For the remainder, use modis_res as a list of images
modis_res = modis_res_nir.toList(modis_res_nir.size())
print(modis_res,'modis_res size')


var runLength = ee.List.sequence(0, modis_res_nir.size().subtract(window_size))
print(runLength, 'runLength')

// Run the SG filter over the series, and get the smoothed image 
var sg_series = runLength.map(function(i) {
  var ref = ee.Image(modis_res.get(ee.Number(i).add(half_window)))
  return getLocalFit(i).multiply(ref.select(indepSelectors)).reduce(ee.Reducer.sum()).copyProperties(ref,['date','system:time_start'])
})

print(sg_series, 'sg_series')

print(Chart.image.series(sg_series, pt, ee.Reducer.mean(), 500)//.select('NDVI')
    //.setSeriesNames(['fitted'])
    .setOptions({
      title: 'NIR_SG_timeseries_3rd Order',
      lineWidth: 1,
      pointSize: 3,
}));

sg_series = ee.ImageCollection(sg_series)

var featureCollection = sg_series.map(function(image) {
    var date = ee.Date(image.get('system:time_start')).format('yyyy-MM-dd HH:mm:ss');
    var medianNDVI = image.reduceRegion({
      reducer: ee.Reducer.median(),
      geometry: pt,
      scale: 30
    }).get('sum');
    return ee.Feature(null, {
      'Date': date,
      'NDVI_Median': medianNDVI
    });
  });
  
print(featureCollection)
  
Export.table.toDrive({
  collection: featureCollection,
  description: 'NDVI_PROBAV333',
  fileFormat: 'CSV'
});


